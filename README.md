# 设计模式总结 (23种)

## 面向对象七大原则

- 单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】: 一个类负责一项职责。
- 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 继承与派生的规则。
- 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。
- 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
- 迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。
- 开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- 组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。

## 设计模式23种总览

### 创建型

1. 单例模式（Singleton Pattern）
2. 工厂方法模式（Factory Method）
3. 抽象工厂模式 (Abstract Factory)
4. 原型模式 (Prototype)
5. 建造者模式 (Builder)

### 结构型

6. 代理模式 (Proxy Pattern)
7. 适配器模式 (Adapter Class/Object)
8. 装饰者模式 (Decorator Pattern)
9. 桥接模式 (Bridge Pattern)
10. 外观模式 (Facade)
11. 组合模式 (Composite Pattern)
12. 享元模式 (Flyweight Pattern)

### 行为型

13. 模版方法模式 (Template Method)
14. 策略模式 (Strategy Pattern)
15. 命令模式 (Command Pattern)
16. 职责链模式 (Chain of Responsibility Pattern)
17. 状态模式 (State Pattern)
18. 观察者模式 (Observer Mode)
19. 中介者模式 (Mediator Pattern)
20. 迭代器模式 (Iterator Pattern)
21. 访问者模式 (Visitor Pattern)
22. 备忘录模式 (Memento Pattern)
23. 解释器模式 (Interpreter Pattern)

## 一、创建型

### 1. 单例模式（Singleton Pattern）

`单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。 这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。`

- 补充描述: 
  - 饿汉式
  - 懒汉式
  - 双重锁
  - 静态内部类
  - 枚举
- 适用场景： 
  - 需要确保在任何情况下绝对只需要一个实例。如：ServletContext，ServletConfig，ApplicationContext，DBPool，ThreadPool等。
- 优点：
  - 在内存中只有一个实例，减少了内存开销。
  - 可以避免对资源的多重占用。
  - 设置全局访问点，严格控制访问。
- 缺点：
  - 没有接口，扩展困难。
  - 如果要扩展单例对象，只有修改代码，没有其它途径。

### 2. 工厂方法模式（Factory Method）

`简单工厂模式不是23种设计模式之一，他可以理解为工厂模式的一种简单的特殊实现。`

`工厂方法模式是指定义一个创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。`

- 补充描述
  - 简单工厂(静态方法)
  - 工厂方法(单一产品复杂实现)
- 适用场景：
  - 工厂类负责创建的对象较少。
  - 客户端只需要传入工厂类的参数，对于如何创建的对象的逻辑不需要关心。
- 优点：
  - 只需要传入一个正确的参数，就可以获取你所需要的对象，无须知道创建的细节。
- 缺点：
  - 工厂类的职责相对过重，增加新的产品类型的时需要修改工厂类的判断逻辑，违背了开闭原则。
  - 不易于扩展过于复杂的产品结构。

### 3. 抽象工厂模式 (Abstract Factory)

`抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。`

- 补充描述:
  - 创建产品簇
- 适用场景：
  - 客户端（应用层）不依赖于产品类实例如何被创建和实现等细节。
  - 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。
  - 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
- 优点：
  - 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- 缺点：
  - 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

### 4. 原型模式 (Prototype)

`原型模式是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数。`

- 补充描述:
  - 浅克隆
  - 深克隆
- 适用场景：
  - 类初始化消耗资源较多。
  - new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）。
  - 构造函数比较复杂。
  - 循环体中生产大量对象时。
- 优点：
  - 性能优良，Java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了许多。
  - 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建的过程。
- 缺点：
  - 必须配备克隆（或者可拷贝）方法。
  - 当对已有类进行改造的时候，需要修改代码，违反了开闭原则。
  - 深克隆、浅克隆需要运用得当。


### 5. 建造者模式 (Builder)

`建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以获得对象，建造过程及细节不需要了解。`

- 适用场景：
  - 适用于创建对象需要很多步骤，但是步骤顺序不一定固定。
  - 如果一个对象有非常复杂的内部结构（属性），把复杂对象的创建和使用进行分离。
- 优点：
  - 封装性好，创建和使用分离。
  - 扩展性好，建造类之间独立、一定程度上解耦。
- 缺点：
  - 产生多余的Builder对象。
  - 产品内部发生变化，建造者都要修改，成本较大。


## 二、结构型

### 6. 代理模式 (Proxy Pattern)

`代理模式是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在访问对象和目标对象之间起到中介作用。`

- 补充描述:
  - 静态代理
  - 动态代理
  - CGlib代理
- 适用场景：
  - 保护目标对象。
  - 增强目标对象。
- 优点：
  - 代理模式能将代理对象与真实被调用的目标对象分离。
  - 一定程度上降低了系统的耦合程度，易于扩展。
  - 代理可以起到保护目标对象的作用。
  - 增强目标对象的职责。
- 缺点：
  - 代理模式会造成系统设计中类的数目增加。
  - 在客户端和目标对象之间增加了一个代理对象，请求处理速度变慢。
  - 增加了系统的复杂度。

### 7. 适配器模式 (Adapter Class/Object)

`适配器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作。适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。`

- 补充描述:
  - 类适配器
  - 对象适配器
  - 接口适配器
- 适用场景：
  - 已经存在的类，它的方法和需求不匹配（方法结构相同或相似）的情况。
  - 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。
- 优点：
  - 能提高类的透明性和复用，现有的类复用但不需要改变。
  - 目标类和适配器类解耦，提高程序的扩展性。
  - 在很多业务场景中符合开闭原则。
- 缺点：
  - 适配器编写过程需要全面考虑，可能会增加系统的复杂性。
  - 增加代码阅读难度，降级代码可读性，过多使用适配器会使系统代码变得凌乱。

### 8. 装饰者模式 (Decorator Pattern)

`装饰模式，是指在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能）`

- 适用场景：
  - 用于扩展一个类的功能或者给一个类添加附加职责。
  - 动态的给一个对象添加功能，这些功能同样也可以再动态的撤销。
- 优点：
  - 装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。
  - 通过使用不同装饰类以及这些装饰类的排列组合，可实现不同效果。
  - 装饰器完全遵守开闭原则。
- 缺点：
  - 会出现更多的代码，更多的类，增加程序的复杂性。
  - 动态装饰时，多层装饰会更复杂。

### 9. 桥接模式 (Bridge Pattern)

`桥接模式也称为桥梁模式、接口模式或者柄体（Handle and Body）模式，是将抽象部分与他的具体实现部分分离，使它们都可以独立地变化，通过组合的方式建立两个类之间的联系，而不是继承。`

- 适用场景：
  - 在抽象和具体实现之间需要增加更多的灵活性的场景。
  - 一个类存在两个（或多个）独立变化的维度，而这两个（或多个）维度都需要独立进行扩展。
  - 不希望使用继承，或因为多层继承导致系统类的个数剧增。
- 优点：
  - 分离抽象部分及其具体实现部分。
  - 提高了系统的扩展性。
  - 符合开闭原型。
  - 符合合成复用原则。
- 缺点：
  - 增加了系统的理解与设计难度。
  - 需要正确地识别系统中两个独立变化的维度。
  
### 10. 外观模式 (Facade)

`外观模式又称门面模式，提供了一个统一的接口，用来访问子系统中的一群接口。`

- 适用场景：
  - 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
  - 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
  - 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。
- 优点：
  - 简化了调用过程，无需深入了解子系统，以防给子系统带来风险。
  - 减少系统依赖、松散耦合。
  - 更好地划分访问层次，提高了安全性。
  - 遵循迪米特法则，即最少知道原则。
- 缺点：
  - 当增加子系统和扩展子系统行为时，可能容易带来未知风险。
  - 不符合开闭原则。
  - 某些情况下可能违背单一职责原则。

  
### 11. 组合模式 (Composite Pattern)

`组合模式也称为整体-部分（Part-Whole）模式，它的宗旨是通过将单个对象（叶子结点）和组合对象（树枝节点）用相同的接口进行表示。`

- 适用场景：
  - 希望客户端可以忽略组合对象与单个对象的差异时。
  - 对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）。
- 优点：
  - 清楚地定义分层次的复杂对象，表示对象的全部或部分层次。
  - 让客户端忽略了层次的差异，方便对整个层次结构进行控制。
  - 简化客户端代码。
  - 符合开闭原则。
- 缺点：
  - 限制类型时会较为复杂。
  - 使设计变得更加抽象。

### 12. 享元模式 (Flyweight Pattern)

`享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构的方式。宗旨：共享细粒度对象，将多个对同一对象的访问集中起来。`

- 补充描述:
  - 内部状态，即不会随着环境的改变而改变的可共享部分。
  - 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。
- 适用场景：
  - 一个系统有大量相同或者相似的对象，造成内存的大量耗费。
  - 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
  - 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。
- 优点：
  - 减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率。
  - 减少内存之外的其他资源占用。
- 缺点：
  - 关注内、外部状态。
  - 关注线程安全问题。
  - 使系统、程序的逻辑复杂化。


## 行为型

### 13. 模版方法模式 (Template Method)

`模板方法模式通常又叫模板模式，是指定义一个算法的骨架，并允许之类为其中的一个或者多个步骤提供实现。模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。`

- 适用场景：
  - 一次性实现一个算法不变的部分，并将可变的行为留给子类来实现。
  - 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。
- 优点：
  - 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。
  - 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。
  - 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。
- 缺点：
  - 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。
  - 类数量的增加，间接地增加了系统实现的复杂度。
  - 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。


### 14. 策略模式 (Strategy Pattern)

`策略模式又叫政策模式（Policy Pattern），它是将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。可以避免多重分支的if......else和switch语句。`

- 适用场景：
  - 系统中有很多类，而它们的区别仅仅在于它们的行为不同。
  - 系统需要动态地在几种算法中选择一种。
  - 需要屏蔽算法规则。
- 优点：
  - 符合开闭原则。
  - 避免使用多重条件语句。
  - 可以提高算法的保密性和安全性。
  - 易于扩展。
- 缺点：
  - 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
  - 代码中会产生非常多的策略类，增加维护难度。

### 15. 命令模式 (Command Pattern)

`命令模式是对命令的封装，每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式解耦了请求方和接收方，请求方只需请求执行命令，不用关心命令是怎样被接收，怎样被操作以及是否被执行等。本质：解耦命令的请求与处理。`

- 适用场景：
  - 现实语义中具备“命令”的操作（如命令菜单，shell命令...）。
  - 请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互。
  - 需要抽象出等待执行的行为，比如撤销操作和恢复操作等。
  - 需要支持命令宏（即命令组合操作）。
- 优点：
  - 通过引入中间件（抽象接口），解耦了命令的请求与实现。
  - 扩展性良好，可以很容易地增加新命令。
  - 支持组合命令，支持命令队列。
  - 可以在现有的命令的基础上，增加额外功能。
- 缺点：
  - 具体命令类可能过多。
  - 增加 了程序的复杂度，理解更加困难。

### 16. 职责链模式 (Chain of Responsibility Pattern)

`职责链模式是将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。`

- 适用场景：
  - 多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。
  - 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
  - 可动态指定一组对象处理请求
- 优点：
  - 将请求与处理解耦。
  - 请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象。
  - 具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果。
  - 链路结构灵活，可以通过改变链路结构动态地新增或删减责任。
  - 易于扩展新的请求处理类（节点），符合开闭原则。
- 缺点：
  - 责任链太长或者处理时间过长，会影响整体性能。
  - 如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。

### 17. 状态模式 (State Pattern)

`状态模式也称为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。`

- 适用场景：
  - 行为随状态改变而改变的场景。
  - 一个操作中含有庞大的多分支结构，并且这些分支取决于对象的状态。
- 优点：
  - 结构清晰：将状态独立为类，消除了冗余的if...else或switch...case语句，使代码更加简洁，提高系统可维护性。
  - 将状态转换显示化：通常的对象内部都是使用数值类型来定义状态，状态的切换是通过赋值进行表现，不够直观；而使用状态类，在切换状态时，是以不同的类进行表示，转换目的更加明确。
  - 状态类职责明确且具备扩展性。
- 缺点：
  - 类膨胀：如果一个事物具备很多状态，则会造成状态类太多。
  - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
  - 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

### 18. 观察者模式 (Observer Mode)

`观察者模式，又叫发布-订阅（Publish/Subscribe）模式，模型-视图（Model/View）模式，源-监听器（Source/Listener）模式或从属者（Dependents）模式。定义一种一对多的依赖关系，一个主题对象可被多个观察者同时监听，使得每当主题对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新。`

- 适用场景：
  - 当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面。
  - 其他一个或多个对象的变化依赖于另一个对象的变化。
  - 实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。
- 优点：
  - 观察者和被观察者是松耦合（抽象耦合）的，符合依赖倒置原则。
  - 分离了表示层（观察者）和数据逻辑层（被观察者），并且建立了一套触发机制，使得数据的变化可以相应到多个表示层上。
  - 实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只有感兴趣的观察者可以接收到通知。
- 缺点：
  - 如果观察者数量过多，则事件通知会耗时较长。
  - 事件通知呈线性关系，如果其中一个观察者处理事件卡壳，会影响后续的观察者接收该事件。
  - 如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃。

### 19. 中介者模式 (Mediator Pattern)

`中介者模式又称为调解者模式或调停者模式。用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。`

- 适用场景：
  - 系统中对象之间存在复杂的引用关系，产生的我相互依赖关系结构混乱且难以理解。
  - 交互的公共行为，如果需要改变行为则可以增加新的中介者类。
- 优点：
  - 减少类间的依赖，将多对多依赖转化成了一对多，降低了类间耦合。
  - 类间各司其职，符合迪米特法则。
- 缺点：
  - 中介者模式中将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。

### 20. 迭代器模式 (Iterator Pattern)

`迭代器模式又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露结合内部表示。`

`本质：抽离集合对象迭代行为到迭代器中，提供一致访问接口。`

- 适用场景：
  - 访问一个集合对象的内容而无需暴露它的内部表示。
  - 为遍历不同的集合结构提供一个统一的访问接口。
- 优点：
  - 多态迭代：为不同的聚合结构提供一致的遍历接口，即一个迭代接口可以访问不同的聚集对象。
  - 简化集合对象接口：迭代器模式将集合对象本身应该提供的元素迭代接口抽取到了迭代器中，使集合对象无须关心具体迭代行为。
  - 元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使的同种元素聚合结构可以有不同的迭代行为。
  - 解耦迭代与集合：迭代器模式封装了具体的迭代算法，迭代算法的变化，不会影响到集合对象的架构。
- 缺点：
  - 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐。
  - 增加了类的个数，在一定程度上增加了系统的复杂性。

### 21. 访问者模式 (Visitor Pattern)

`访问者模式是一种将数据结构与数据操作分离的设计模式。是指封装一些作用于某种数据结构中的各元素的操作。`

`特征：可以在不改变数据结构的前提下定义作用于这些元素的新的操作。`

- 补充描述:
  - 静态分派(Static Dispatch) 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。
  - 动态分派(Dynamic Dispatch) 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。
- 适用场景：
  - 数据结构稳定，作用于数据结构的操作经常变化的场景。
  - 需要数据结构与数据操作分离的场景。
  - 需要对不同数据类型（元素）进行操作，而不使用分支判断具体类型的场景。
- 优点：
  - 解耦了数据结构与数据操作，使得操作集合可以独立变化。
  - 扩展性好：可以通过扩展访问者角色，实现对数据集的不同操作。
  - 元素具体类型并非单一，访问者均可操作。
  - 各角色职责分离，符合单一职责原则。
- 缺点：
  - 无法增加元素类型：若系统数据结构对象易于变化，经常有新的数据对象增加进来，则访问者类必须增加对应元素类型的操作，违背了开闭原则。
  - 具体元素变更困难：具体元素增加属性，删除属性等操作会导致对应的访问者类需要进行相应的修改，尤其当有大量访问者类时，修改访问太大。
  - 违背依赖倒置原则：为了达到“区别对待”，访问者依赖的是具体元素类型，而不是抽象。

### 22. 备忘录模式 (Memento Pattern)

`备忘录模式又称为快照模式（Snapshot Pattern）或令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。`

- 适用场景：
  - 需要保存历史快照的场景。
  - 希望在对象之外保存状态，且除了自己其他类对象无法访问状态保存具体内容。
- 优点：
  - 简化发起人实体类职责，隔离状态存储与获取，实现了信息的封装，客户端无需关心状态的保存细节。
  - 提供状态回滚功能。
- 缺点：
  - 消耗资源：如果需要保存的状态过多时，每一次保存都会消耗很多内存。


### 23. 解释器模式 (Interpreter Pattern)

`解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。`

`特征：为了解释一种语言，而为语言创建的解释器。`

- 适用场景：
  - 一些重复出现的问题可以用一种简单的语言来进行表述。
  - 一个简单语法需要解释的场景。
- 优点：
  - 扩展性强：在解释器模式中由于语法是由很多类表示的，当语法规则更改时，只需修改相应的非终结符表达式即可；若扩展语法时，只需添加相应非终结符类即可。
  - 增加了新的解释表达式的方式。
  - 易于实现文法：解释器模式对应的文法应当是比较简单且易于实现的，过于复杂的语法并不适合使用解释器模式。
- 缺点：
  - 语法规则较复杂时，会引起类膨胀。
  - 执行效率比较低


